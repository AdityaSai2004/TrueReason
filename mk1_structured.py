import json
import re
import subprocess
import os
from openai import OpenAI
from dotenv import load_dotenv

def initialize_openai_client():
    """
    Initialize and return the OpenAI client using the API key from environment variables.

    Returns:
        OpenAI: An instance of the OpenAI client.

    Raises:
        EnvironmentError: If the API key is not found in environment variables.
    """
    load_dotenv()
    api_key = os.getenv("OPEN_ROUTER_API")
    if not api_key:
        raise EnvironmentError("API key not found in environment variables.")
    return OpenAI(
        base_url="https://openrouter.ai/api/v1",
        api_key=api_key
    )

def create_completion(client, prompt):
    """
    Create a completion using the OpenAI client and the provided prompt.

    Args:
        client (OpenAI): The OpenAI client instance.
        prompt (str): The prompt to send to the model.

    Returns:
        dict: The completion response from the model.

    Raises:
        Exception: If the API call fails or returns an unexpected response.
    """
    try:
        completion = client.chat.completions.create(
            model="google/gemini-2.0-pro-exp-02-05:free",
            messages=[
                {
                    "role": "developer",
                    "content": (
                        "You are an assistant with access to a Python execution environment.\n"
                        "Your response **must** always be in JSON format.\n"
                        "- If the question can be solved with code, return:\n"
                        "  ```json\n"
                        "  {\"type\": \"code\", \"code\": \"<generated Python code>\"}\n"
                        "  ```\n"
                        "- If it does not require code, return:\n"
                        "  ```json\n"
                        "  {\"type\": \"text\", \"answer\": \"<natural language response>\"}\n"
                        "  ```\n"
                        "- If multiple questions with different types are asked, return\n"
                        "  the non-code response also in the code as a print statement.\n"
                        "Prefer to generate code whenever possible."
                    ),
                },
                {
                    "role": "user",
                    "content": prompt,
                }
            ]
        )
        return completion
    except Exception as e:
        raise Exception(f"Failed to create completion: {e}")

def parse_response(raw_response):
    """
    Parse the raw response from the model, removing code block markers if present.

    Args:
        raw_response (str): The raw response string from the model.

    Returns:
        dict: The parsed JSON content as a dictionary.

    Raises:
        ValueError: If the response cannot be parsed as JSON.
    """
    raw_response = raw_response.strip()
    if raw_response.startswith("```json") and raw_response.endswith("```"):
        raw_response = re.sub(r"^```json|\n```$", "", raw_response).strip()
    try:
        return json.loads(raw_response)
    except json.JSONDecodeError as e:
        raise ValueError(f"Error parsing JSON: {e}")

def execute_code(code):
    """
    Execute the provided Python code in a subprocess and capture its output.

    Args:
        code (str): The Python code to execute.

    Returns:
        str: The standard output or error message from the code execution.

    Raises:
        RuntimeError: If the code execution fails.
    """
    try:
        result = subprocess.run(
            ["python", "-c", code], capture_output=True, text=True, timeout=5
        )
        return result.stdout.strip() if result.stdout else result.stderr.strip()
    except Exception as e:
        raise RuntimeError(f"Error during code execution: {e}")

def refine_answer(client, prompt, generated_code, execution_result):
    """
    Send the execution result back to the model to obtain a refined, well-informed answer.

    Args:
        client (OpenAI): The OpenAI client instance.
        prompt (str): The original user prompt.
        generated_code (str): The code generated by the model.
        execution_result (str): The result of executing the generated code.

    Returns:
        str: The final answer from the model.

    Raises:
        Exception: If the API call fails or returns an unexpected response.
    """
    refinement_prompt = {
        "role": "user",
        "content": (
            f"You were asked a question:\n"
            f"{prompt}\n"
            f"You generated the following Python code to solve it:\n"
            f"```python\n"
            f"{generated_code}\n"
            f"```\n"
            f"The execution result was:\n"
            f"```\n"
            f"{execution_result}\n"
            f"```\n"
            f"Now, based on this, provide a final, well-informed answer to the user's original question."
        ),
    }
    try:
        refined_completion = client.chat.completions.create(
            model="google/gemini-2.0-pro-exp-02-05:free",
            messages=[refinement_prompt]
        )
        return refined_completion.choices[0].message.content.strip()
    except Exception as e:
        raise Exception(f"Failed to refine answer: {e}")

def main():
    """
    Main function to execute the workflow:
    1. Initialize the OpenAI client.
    2. Create a completion based on the user prompt.
    3. Parse the model's response.
    4. If code is generated, execute it and refine the answer.
    5. Print the final answer.
    """
    prompt = (
        "I picked 44 apples yesterday. And then I picked 22 more. "
        "Today I picked twice the number of apples I picked yesterday but 5 of them were smaller than average. "
        "How many apples do I have in total?"
    )

    try:
        client = initialize_openai_client()
        completion = create_completion(client, prompt)
        raw_response = completion.choices[0].message.content
        response_data = parse_response(raw_response)

        if response_data.get("type") == "code":
            generated_code = response_data.get("code", "")
            print("Generated Code:\n", generated_code)
            execution_result = execute_code(generated_code)
            print("Execution Result:\n", execution_result)
            final_answer = refine_answer(client, prompt, generated_code, execution_result)
            print("\nFinal Answer:\n", final_answer)
        elif response_data.get("type") == "text":
            answer = response_data.get("answer", "")
            print("Answer:\n", answer)
        else:
            print("Unexpected response format:", response_data)
    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    main()
